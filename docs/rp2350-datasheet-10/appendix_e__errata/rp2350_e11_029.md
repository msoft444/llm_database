---
source_pdf: rp2350-datasheet-10.pdf
repository: llm_database
chapter: Appendix E: Errata
section: RP2350-E11
pages: 1375-1376
type: technical_spec
generated_at: 2026-03-01T12:20:14.494106+00:00
---

# RP2350-E11

RP2350-E11

| Reference | RP2350-E11 |
| --- | --- |
| Summary | XIP cache clean by set/way operation modifies the tag of dirty lines |
| Affects | RP2350 A2, RP2350 A3, RP2350 A4 |
| Description | The 0x1 clean by set/way cache maintenance operation performs the following steps: 1. Selects a cache line: address bits 12:3 index the cache sets, and bit 13 selects from the two 8-byte cache lines, which make up the ways of each set. 2. Checks if the line contains uncommitted write data (a dirty line). 3. If the line is dirty, writes the data downstream and marks the line as clean. In the third step, in addition to marking the line as clean, the cache controller erroneously sets the cache line’s tag to address bits 25:13 of the maintenance write that initiated the clean operation. The cache uses the tag to recall which of the many possible downstream addresses currently resides in each cache line. Therefore reading the newly tagged address returns cached data from the original address, breaking the memory contract. Consider the following example scenario: • QMI window 0 (starting at 0x10000000) has a flash device attached • QMI window 1 (starting at 0x11000000) has a PSRAM device attached • The cache possesses address 0x11000000 in the dirty state, and it is allocated in way 0 of the cache The programmer cleans the cache, starting by writing to address 0x18000001 to clean set 0, way 0. This cleans the dirty line containing address 0x11000000. After cleaning, the cache updates this line’s tag to all- zeroes (the offset of the maintenance write). A subsequent read from 0x10000000 results in a spurious cache hit, returning PSRAM data in place of flash data. See Section 4.4.1.1 for more information about cache maintenance operations. See Section 4.4.1.2 for more information about cache line states and state transitions. The tag update only affects 0x1 clean by set/way; is either correct or harmless for the other four cache maintenance operations. |
| Workaround | To avoid spurious cache hits, choose an address that can’t alias with cached data from the QMI. This remaps dirty lines outside of the QMI address space after cleaning them, which has the side effect of causing a cache miss on the next access to the dirty address. The SDK xip cache clean all() function _ _ _ implements this workaround. The updated tag is predictable: it is always the address of the maintenance write. For example, use the upper 16 kB of the maintenance space to clean all cache lines: 1 volatile uint8_t *maintenance_ptr = (volatile uint8_t*)0x1bffc001u; 2 for (int i = 0; i < 0x4000; i += 8) { 3 maintenance_ptr[i] = 0; 4 } Because the clean operation is a no-op for invalid, clean or pinned lines, this workaround doesn’t interfere with lines pinned for cache-as-SRAM use. |
| Fixed by | Documentation, Software |

XIP
1374

RP2350 Datasheet

USB
