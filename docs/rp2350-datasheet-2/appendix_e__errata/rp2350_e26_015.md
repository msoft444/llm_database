---
source_pdf: rp2350-datasheet-2.pdf
repository: llm_database
chapter: Appendix E: Errata
section: RP2350-E26
pages: 1373-1373
type: technical_spec
generated_at: 2026-02-28T17:43:10.557178+00:00
---

# RP2350-E26

![Page 1373 figure](images/fig_p1373.png)

RP2350 Datasheet

| Description | As described in Section 13.5, the uppermost 64 words (128 rows) of OTP contain protection information
for each 128-byte page of OTP. The total ECC data capacity of the OTP is 64 × 128 B = 8192 B, so there is
one such lock word for each page. The permissions in each lock word n cover OTP rows 64 * n through 64
* n + 63 (inclusive), and they also cover the lock word itself.
This makes lock words 62 and 63 special because they don’t have any associated OTP page. This is
because those pages would overlap with the locations where the lock words are stored. Instead, lock
words 62 and 63 should only protect themselves. This rule is applied correctly for the effects of LOCK NS
_
and LOCK S bits. However, the protection checks for the KEY R, KEY W, and NO KEY STATE bits don’t handle
_ _ _ _ _
pages 62 and 63 correctly. Instead, they simply divide the row number by 64 to look up the lock word.
The effect is that lock words 0 through 31 have a key protection state defined by PAGE62_LOCK0, and
lock words 32 through 63 have a key protection state defined by PAGE63_LOCK0.
Conversely, the key configuration in lock words 0 through 61 does not affect the accessibility of those
lock words. It only affects the accessibility of the actual data pages protected by those lock words. |
| --- | --- |
| Workaround | As a partial mitigation, factory programming revokes Non-secure write permission to pages 62 and 63 on
all devices. This avoids Non-secure software disabling Secure access to lock words by deliberately
installing an invalid key. For the full list of permissions pre-programmed on blank devices, see Section
13.5.5. This mitigation is applied on all versions of RP2350.
Software shouldn’t rely on OTP access keys for protection of lock words. |
| Fixed by | Documentation |

RCP

RP2350-E26

| Reference | RP2350-E26 |
| --- | --- |
| Summary | RCP random delays can create a side-channel |
| Affects | RP2350 A2, RP2350 A3, RP2350 A4 |
| Description | The RCP delay is implemented as a coprocessor stall; this has the effect of completely pausing the
associated core. As the core is effectively halted for the duration of the delay, this represents a
significant reduction in gate toggle activity across the chip if there are no other bus managers active (e.g.
other CPU or DMA). The reduction in toggle activity causes a reduction in DVDD current, and the typical
length of the delay means that the reduction is measureable outside of the chip. The reduction in current
and subsequent increase may create a fault injection trigger point. Instructions immediately after an RCP
delay operation can be more reliably targeted, undoing the cumulative effect of clock randomisation.
A second-order effect of the RCP delay probability distribution is that after N RCP instructions for large N,
the added latency converges to a normal distribution centred on N * 63 cycles. Therefore, instructions
after a known number of RCP delays are statistically easier to target.
With these two factors in mind, programmers should use RCP delays in Secure code with great care. In
particular, avoid using RCP delays:
• Inside inner loops that may be executed many times.
• As part of boilerplate assembly in function prologues/epilogues.
• Immediately prior to particularly critical actions, such as modifying ACCESSCTRL.
As a mitigation, as of RP2350 A3, the bootrom uses the non-delay variant for all RCP instructions. |
| Workaround | Use of the non-delay RCP instruction variant is recommended. |

RCP
1372
