---
source_pdf: rp2350-datasheet-2.pdf
repository: llm_database
chapter: Chapter 11. PIO
section: 11.6.3. UART TX
pages: 922-923
type: technical_spec
generated_at: 2026-02-28T17:43:10.557178+00:00
---

# 11.6.3. UART TX

![Page 922 figure](images/fig_p0922.png)

RP2350 Datasheet


TIP

The WS2812 example is the subject of a tutorial in the Raspberry Pi Pico-series C/C++ SDK document, in the PIO

chapter. The tutorial dissects the ws2812 program line by line, traces through how the program executes, and shows

wave diagrams of the GPIO output at every point in the program.

11.6.3. UART TX

Figure 58. UART serial

|  |  |  |  |  |  |  |  |  |  |  |  |  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
|  |  |  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |  |  |
| Idle |  | Start |  |  |  | Data ( | LSB first | ) |  |  | Stop |  |

Bit Clock

format. The line is

TX

high when idle. The

State

transmitter pulls the

line down for one bit

period to signify the

This program implements the transmit component of a universal asynchronous receive/transmit (UART) serial

start of a serial frame

peripheral. Perhaps it would be more correct to refer to this as a UAT.

(the "start bit"), and a

small, fixed number of

data bits follows. The

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_tx/uart_tx.pio Lines 8 - 18

line returns to the idle

state for at least one

 8 .program uart_tx

bit period (the "stop

 9 .side_set 1 opt

bit") before the next

10 

serial frame can

begin.

11 ; An 8n1 UART transmit program.

12 ; OUT pin 0 and side-set pin 0 are both mapped to UART TX pin.

13 

14     pull       side 1 [7]  ; Assert stop bit, or stall with line in idle state

15     set x, 7   side 0 [7]  ; Preload bit counter, assert start bit for 8 clocks

16 bitloop:                   ; This loop will run 8 times (8n1 UART)

17     out pins, 1            ; Shift 1 bit from OSR to the first OUT pin

18     jmp x-- bitloop   [6]  ; Each loop iteration is 8 cycles.

As written, it will:

1. Stall with the pin driven high until data appears (noting that side-set takes effect even when the state machine is

stalled)

2. Assert a start bit, for 8 SM execution cycles

3. Shift out 8 data bits, each lasting for 8 cycles

4. Return to the idle line state for at least 8 cycles before asserting the next start bit

If the state machine’s clock divider is configured to run at 8 times the desired baud rate, this program will transmit well-

formed UART serial frames, whenever data is pushed to the TX FIFO either by software or the system DMA. To extend

the program to cover different frame sizes (different numbers of data bits), the set x, 7 could be replaced with mov x, y,

so that the y scratch register becomes a per-SM configuration register for UART frame size.

The .pio file in the SDK also contains this function, for configuring the pins and the state machine, once the program

has been loaded into the PIO instruction memory:

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_tx/uart_tx.pio Lines 24 - 51

24 static inline void uart_tx_program_init(PIO pio, uint sm, uint offset, uint pin_tx, uint

   baud) {

25     // Tell PIO to initially drive output-high on the selected pin, then map PIO

26     // onto that pin with the IO muxes.

27     pio_sm_set_pins_with_mask64(pio, sm, 1ull << pin_tx, 1ull << pin_tx);

28     pio_sm_set_pindirs_with_mask64(pio, sm, 1ull << pin_tx, 1ull << pin_tx);

29     pio_gpio_init(pio, pin_tx);

30 

31     pio_sm_config c = uart_tx_program_get_default_config(offset);

11.6. Examples
921

![Page 923 figure](images/fig_p0923.png)

RP2350 Datasheet

32 

33     // OUT shifts to right, no autopull

34     sm_config_set_out_shift(&c, true, false, 32);

35 

36     // We are mapping both OUT and side-set to the same pin, because sometimes

37     // we need to assert user data onto the pin (with OUT) and sometimes

38     // assert constant values (start/stop bit)

39     sm_config_set_out_pins(&c, pin_tx, 1);

40     sm_config_set_sideset_pins(&c, pin_tx);

41 

42     // We only need TX, so get an 8-deep FIFO!

43     sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);

44 

45     // SM transmits 1 bit per 8 execution cycles.

46     float div = (float)clock_get_hz(clk_sys) / (8 * baud);

47     sm_config_set_clkdiv(&c, div);

48 

49     pio_sm_init(pio, sm, offset, &c);

50     pio_sm_set_enabled(pio, sm, true);

51 }

The state machine is configured to shift right in out instructions, because UARTs typically send data LSB-first. Once

configured, the state machine will print any characters pushed to the TX FIFO.

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_tx/uart_tx.pio Lines 53 - 55

53 static inline void uart_tx_program_putc(PIO pio, uint sm, char c) {

54     pio_sm_put_blocking(pio, sm, (uint32_t)c);

55 }

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_tx/uart_tx.pio Lines 57 - 60

57 static inline void uart_tx_program_puts(PIO pio, uint sm, const char *s) {

58     while (*s)

59         uart_tx_program_putc(pio, sm, *s++);

60 }

The example program in the SDK will configure one PIO state machine as a UART TX peripheral, and use it to print a

message on GPIO 0 at 115200 baud once per second.

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_tx/uart_tx.c

 1 /**

 2  * Copyright (c) 2020 Raspberry Pi (Trading) Ltd.

 3  *

 4  * SPDX-License-Identifier: BSD-3-Clause

 5  */

 6 

 7 #include "pico/stdlib.h"

 8 #include "hardware/pio.h"

 9 #include "uart_tx.pio.h"

10 

11 // We're going to use PIO to print "Hello, world!" on the same GPIO which we

12 // normally attach UART0 to.

13 #define PIO_TX_PIN 0

14 

15 // Check the pin is compatible with the platform

16 #error Attempting to use a pin>=32 on a platform that does not support it

11.6. Examples
922
