---
source_pdf: rp2350-datasheet-3.pdf
repository: llm_database
chapter: Chapter 12. Peripherals
section: 12.6.4. Data request (DREQ)
pages: 1101-1102
type: technical_spec
generated_at: 2026-03-01T02:30:35.833805+00:00
---

# 12.6.4. Data request (DREQ)

RP2350 Datasheet

12.6.3.2. Chaining

When a channel completes, it can name a different channel to immediately be triggered. This can be used as a callback

for the second channel to reconfigure and restart the first.

This feature is configured through the CHAIN_TO field in the channel CTRL register. This 4-bit value selects a channel that

will start when this one finishes. A channel cannot chain to itself. Setting CHAIN_TO to a channel’s own index prevents

chaining.

Chain triggers behave the same as triggers from other sources, such as trigger registers. For example, they cause

TRANS_COUNT to reload, and they are ignored if the targeted channel is already running.

One application for CHAIN_TO is for a channel to request reconfiguration by another channel from a sequence of control

blocks in memory. Channel A is configured to perform a wrapped transfer from memory to channel B’s control registers

(including a trigger register), and channel B is configured to chain back to channel A when it completes each transfer

sequence. This is shown explicitly in the DMA control blocks example (Section 12.6.9.2).

Use of the register aliases (Section 12.6.3.1) enables compact formats for DMA control blocks: as little as one word, in

some cases.

Another use of chaining is a ping-pong configuration, where two channels each trigger one another. The processor can

respond to the channel completion interrupts and reconfigure each channel after it completes. However, the chained

channel, which has already been configured, starts immediately. In other words, channel configuration and channel

operation are pipelined. This can improve performance dramatically when a usage pattern requires many short transfer

sequences.

The Section 12.6.9 goes into more detail on the possibilities of chain triggers in the real world.

12.6.3.3. Null triggers and chain interrupts

As mentioned in Section 12.6.3.1, writing all-zeroes to a trigger register does not start the channel. This is called a null

trigger, and it has two purposes:

• Cause a halt at the end of an array of control blocks, by appending an all-zeroes block.
• Reduce the number of interrupts generated when using control blocks.

By default, channels generate an interrupt each time they finish a transfer sequence, unless that channel’s IRQ is

masked in INTE0 through INTE3. The rate of interrupts can be excessive, particularly as processor attention is generally

not required while a sequence of control blocks are in progress. However, processor attention is required at the end of a

chain.

The channel CTRL register has a field called IRQ_QUIET. Its default value is 0. When this set to 1, channels generate an

interrupt when they receive a null trigger, but not on normal completion of a transfer sequence. The interrupt is

generated by the channel that receives the trigger.

12.6.4. Data request (DREQ)

Peripherals produce or consume data at their own pace. If the DMA transferred data as fast as possible, loss or

corruption of data would ensue. DREQs are a communication channel between peripherals and the DMA that enables

the DMA to pace transfers according to the needs of the peripheral.

The CTRL.TREQ_SEL (transfer request) field selects an external DREQ. It can also be used to select one of the internal

pacing timers, or select no TREQ at all (the transfer proceeds as fast as possible), e.g. for memory-to-memory transfers.

12.6.4.1. System DREQ table

DREQ numbers use the following global assignment to peripheral DREQ channels:

12.6. DMA
1100

![Page 1102 figure](images/fig_p1102.png)

RP2350 Datasheet

| DREQ | DREQ Channel | DREQ | DREQ Channel | DREQ | DREQ Channel | DREQ | DREQ Channel |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 0 | DREQ PIO0 TX0 _ _ | 14 | DREQ PIO1 RX2 _ _ | 28 | DREQ UART0 TX _ _ | 42 | DREQ PWM WRAP10 _ _ |
| 1 | DREQ PIO0 TX1 _ _ | 15 | DREQ PIO1 RX3 _ _ | 29 | DREQ UART0 RX _ _ | 43 | DREQ PWM WRAP11 _ _ |
| 2 | DREQ PIO0 TX2 _ _ | 16 | DREQ PIO2 TX0 _ _ | 30 | DREQ UART1 TX _ _ | 44 | DREQ I2C0 TX _ _ |
| 3 | DREQ PIO0 TX3 _ _ | 17 | DREQ PIO2 TX1 _ _ | 31 | DREQ UART1 RX _ _ | 45 | DREQ I2C0 RX _ _ |
| 4 | DREQ PIO0 RX0 _ _ | 18 | DREQ PIO2 TX2 _ _ | 32 | DREQ PWM WRAP0 _ _ | 46 | DREQ I2C1 TX _ _ |
| 5 | DREQ PIO0 RX1 _ _ | 19 | DREQ PIO2 TX3 _ _ | 33 | DREQ PWM WRAP1 _ _ | 47 | DREQ I2C1 RX _ _ |
| 6 | DREQ PIO0 RX2 _ _ | 20 | DREQ PIO2 RX0 _ _ | 34 | DREQ PWM WRAP2 _ _ | 48 | DREQ ADC _ |
| 7 | DREQ PIO0 RX3 _ _ | 21 | DREQ PIO2 RX1 _ _ | 35 | DREQ PWM WRAP3 _ _ | 49 | DREQ XIP STREAM _ _ |
| 8 | DREQ PIO1 TX0 _ _ | 22 | DREQ PIO2 RX2 _ _ | 36 | DREQ PWM WRAP4 _ _ | 50 | DREQ XIP QMITX _ _ |
| 9 | DREQ PIO1 TX1 _ _ | 23 | DREQ PIO2 RX3 _ _ | 37 | DREQ PWM WRAP5 _ _ | 51 | DREQ XIP QMIRX _ _ |
| 10 | DREQ PIO1 TX2 _ _ | 24 | DREQ SPI0 TX _ _ | 38 | DREQ PWM WRAP6 _ _ | 52 | DREQ HSTX _ |
| 11 | DREQ PIO1 TX3 _ _ | 25 | DREQ SPI0 RX _ _ | 39 | DREQ PWM WRAP7 _ _ | 53 | DREQ CORESIGHT _ |
| 12 | DREQ PIO1 RX0 _ _ | 26 | DREQ SPI1 TX _ _ | 40 | DREQ PWM WRAP8 _ _ | 54 | DREQ SHA256 _ |
| 13 | DREQ PIO1 RX1 _ _ | 27 | DREQ SPI1 RX _ _ | 41 | DREQ PWM WRAP9 _ _ |  |  |

12.6.4.2. Credit-based DREQ Scheme

The RP2350 DMA is designed for systems where:

• The area and power cost of large peripheral data FIFOs is prohibitive.
• The bandwidth demands of individual peripherals can be high, for example, >50% bus injection rate for short

periods.
• Bus latency is low, but multiple managers can compete for bus access.

In addition, the DMA’s transfer FIFOs and dual-manager-port structure permit multiple accesses to the same peripheral

to be in-flight at once to improve throughput. Choice of DREQ mechanism is therefore critical:

• The traditional "turn on the tap" method can cause overflow if multiple writes are backed up in the TDF. Some

systems solve this by over-provisioning peripheral FIFOs and setting the DREQ threshold below the full level at the

expense of precious area and power.
• The Arm-style single and burst handshake does not permit additional requests to be registered while the current

request is being served. This limits performance when FIFOs are very shallow.

The RP2350 DMA uses a credit-based DREQ mechanism. For each peripheral, the DMA attempts to keep as many

transfers in-flight as the peripheral has capacity for. This enables full bus throughput (1 word per clock) through an 8-

deep peripheral FIFO with no possibility of overflow or underflow in the absence of fabric latency or contention.

For each channel, the DMA maintains a counter. Each 1-clock pulse on the dreq signal increments this counter. When

non-zero, the channel requests a transfer from the DMA’s internal arbiter. The counter decrements when the transfer is

issued to the address FIFOs. At this point the transfer is in flight, but has not yet necessarily completed.

The counter is saturating, and six bits in size. The counter ignores increments at the maximum value or decrements at

zero. The six-bit counter size supports counts up to the depth of any FIFO on RP2350.

12.6. DMA
1101
