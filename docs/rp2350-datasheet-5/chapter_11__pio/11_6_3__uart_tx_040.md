---
source_pdf: rp2350-datasheet-5.pdf
repository: llm_database
chapter: Chapter 11. PIO
section: 11.6.3. UART TX
pages: 922-924
type: technical_spec
generated_at: 2026-03-01T04:13:03.328193+00:00
---

# 11.6.3. UART TX

![Page 922 figure](images/fig_p0922.png)

Figure 58. UART serial

format. The line is

1
0
2
3
4
5
6
7

high when idle. The

Start
Stop
Data (LSB first)
Idle

transmitter pulls the

line down for one bit

period to signify the

This program implements the transmit component of a universal asynchronous receive/transmit (UART) serial

start of a serial frame

peripheral. Perhaps it would be more correct to refer to this as a UAT.

(the "start bit"), and a

small, fixed number of

data bits follows. The

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_tx/uart_tx.pio Lines 8 - 18

line returns to the idle

state for at least one

bit period (the "stop

bit") before the next

serial frame can

begin.

11 ; An 8n1 UART transmit program.

12 ; OUT pin 0 and side-set pin 0 are both mapped to UART TX pin.

14     pull       side 1 [7]  ; Assert stop bit, or stall with line in idle state

15     set x, 7   side 0 [7]  ; Preload bit counter, assert start bit for 8 clocks

16 bitloop:                   ; This loop will run 8 times (8n1 UART)

17     out pins, 1            ; Shift 1 bit from OSR to the first OUT pin

18     jmp x-- bitloop   [6]  ; Each loop iteration is 8 cycles.

1. Stall with the pin driven high until data appears (noting that side-set takes effect even when the state machine is

2. Assert a start bit, for 8 SM execution cycles

3. Shift out 8 data bits, each lasting for 8 cycles

4. Return to the idle line state for at least 8 cycles before asserting the next start bit

If the state machine’s clock divider is configured to run at 8 times the desired baud rate, this program will transmit well-

formed UART serial frames, whenever data is pushed to the TX FIFO either by software or the system DMA. To extend

the program to cover different frame sizes (different numbers of data bits), the set x, 7 could be replaced with mov x, y,

so that the y scratch register becomes a per-SM configuration register for UART frame size.

The .pio file in the SDK also contains this function, for configuring the pins and the state machine, once the program

has been loaded into the PIO instruction memory:

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_tx/uart_tx.pio Lines 24 - 51

24 static inline void uart_tx_program_init(PIO pio, uint sm, uint offset, uint pin_tx, uint

25     // Tell PIO to initially drive output-high on the selected pin, then map PIO

26     // onto that pin with the IO muxes.

27     pio_sm_set_pins_with_mask64(pio, sm, 1ull << pin_tx, 1ull << pin_tx);

28     pio_sm_set_pindirs_with_mask64(pio, sm, 1ull << pin_tx, 1ull << pin_tx);

29     pio_gpio_init(pio, pin_tx);

31     pio_sm_config c = uart_tx_program_get_default_config(offset);

11.6. Examples
921

RP2350 Datasheet

![Page 923 figure](images/fig_p0923.png)

33     // OUT shifts to right, no autopull

34     sm_config_set_out_shift(&c, true, false, 32);

36     // We are mapping both OUT and side-set to the same pin, because sometimes

37     // we need to assert user data onto the pin (with OUT) and sometimes

38     // assert constant values (start/stop bit)

39     sm_config_set_out_pins(&c, pin_tx, 1);

40     sm_config_set_sideset_pins(&c, pin_tx);

42     // We only need TX, so get an 8-deep FIFO!

43     sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);

45     // SM transmits 1 bit per 8 execution cycles.

46     float div = (float)clock_get_hz(clk_sys) / (8 * baud);

47     sm_config_set_clkdiv(&c, div);

49     pio_sm_init(pio, sm, offset, &c);

50     pio_sm_set_enabled(pio, sm, true);

The state machine is configured to shift right in out instructions, because UARTs typically send data LSB-first. Once

configured, the state machine will print any characters pushed to the TX FIFO.

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_tx/uart_tx.pio Lines 53 - 55

53 static inline void uart_tx_program_putc(PIO pio, uint sm, char c) {

54     pio_sm_put_blocking(pio, sm, (uint32_t)c);

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_tx/uart_tx.pio Lines 57 - 60

57 static inline void uart_tx_program_puts(PIO pio, uint sm, const char *s) {

59         uart_tx_program_putc(pio, sm, *s++);

The example program in the SDK will configure one PIO state machine as a UART TX peripheral, and use it to print a

message on GPIO 0 at 115200 baud once per second.

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_tx/uart_tx.c

 2  * Copyright (c) 2020 Raspberry Pi (Trading) Ltd.

 4  * SPDX-License-Identifier: BSD-3-Clause

11 // We're going to use PIO to print "Hello, world!" on the same GPIO which we

12 // normally attach UART0 to.

15 // Check the pin is compatible with the platform

16 #error Attempting to use a pin>=32 on a platform that does not support it

11.6. Examples
922

RP2350 Datasheet

![Page 924 figure](images/fig_p0924.png)

19     // This is the same as the default UART baud rate on Pico

20     const uint SERIAL_BAUD = 115200;

26     // This will find a free pio and state machine for our program and load it for us

27     // We use pio_claim_free_sm_and_add_program_for_gpio_range (for_gpio_range variant)

28     // so we will get a PIO instance suitable for addressing gpios >= 32 if needed and

29     bool success = pio_claim_free_sm_and_add_program_for_gpio_range(&uart_tx_program, &pio,

   &sm, &offset, PIO_TX_PIN, 1, true);

32     uart_tx_program_init(pio, sm, offset, PIO_TX_PIN, SERIAL_BAUD);

35         uart_tx_program_puts(pio, sm, "Hello, world! (from PIO!)\r\n");

39     // This will free resources and unload our program

40     pio_remove_program_and_unclaim_sm(&uart_tx_program, pio, sm, offset);

With the two PIO instances on RP2350, this could be extended to 8 additional UART TX interfaces, on 8 different pins,
