---
source_pdf: rp2350-datasheet-6.pdf
repository: llm_database
chapter: Chapter 8. Clocks
section: 8.1.5. Resus
pages: 523-524
type: technical_spec
generated_at: 2026-03-01T05:39:21.783275+00:00
---

# 8.1.5. Resus

![Page 523 figure](images/fig_p0523.png)

It is possible to write software that inadvertently stops clk_sys. This normally causes an unrecoverable lock-up of the

cores and the on-chip debugger, leaving the user unable to trace the problem. To mitigate against unrecoverable core

lock-up, an automatic resuscitation circuit is provided; this switches clk_sys to a known good clock source (clk_ref) if it

detects no edges over a user-defined interval. clk_ref can be driven from the XOSC, ROSC or an external source. The

interval is programmable via CLK_SYS_RESUS_CTRL.

There is no way for resus to revive the chip if clk_ref is also stopped.

To enable the resus:

• Set the timeout interval.
• Set the ENABLE bit in CLK_SYS_RESUS_CTRL.

To detect a resus event:

• Enable the CLK_SYS_RESUS interrupt by setting the interrupt enable bit in INTE.

8.1. Overview
522

RP2350 Datasheet

• Enable the CLOCKS_DEFAULT_IRQ processor interrupt (see Section 3.2, “Interrupts”).

Resus is intended as a debugging aid, so the user can trace the software error that triggered the resus, then correct the

error and reboot. It is possible to continue running after a resus event by reconfiguring clk_sys, then clearing the resus

by writing the CLEAR bit in CLK_SYS_RESUS_CTRL.

WARNING

Only use resus for debugging. If clk_sys runs slower than expected, a resus could trigger. This could result in a

clk_sys glitch, which could corrupt the chip.
