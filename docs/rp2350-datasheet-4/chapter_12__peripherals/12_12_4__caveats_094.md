---
source_pdf: rp2350-datasheet-4.pdf
repository: llm_database
chapter: Chapter 12. Peripherals
section: 12.12.4. Caveats
pages: 1215-1215
type: technical_spec
generated_at: 2026-03-01T03:27:49.792955+00:00
---

# 12.12.4. Caveats

RP2350 Datasheet

12.12.4. Caveats

The generation of random numbers by the TRNG block is not a deterministic process.

Although the modal and mean average times required to generate random numbers are quite similar, the generation

process can occasionally take much longer to complete: in excess of 100 times the average. Any run resulting in a failed

entropy check discards the result, requiring another generation process.

You can accommodate these unpredictable generation times in your system design. For example, you might generate a

small pool of random numbers, initiating subsequent generation whenever space becomes available in the pool.

In the interests of simplicity and timing predictability, alternative approaches were adopted for the RP2350 bootrom and

the SDK TRNG block drivers. The methodologies used can be found via the links below. However, nothing in the TRNG

block in RP2350 precludes using the block as specified in Arm documentation.

12.12.4.1. Bootrom

The bootrom streams raw TRNG ROSC samples (the TRNG random source) directly into the hardware SHA-256

accelerator. It bypasses all internal checking and conditioning in the TRNG. SHA-256 is a robust hash function which

avoids the pitfalls of some of the conditioning logic in the TRNG, most notably the von Neumann decorrelator.

The bootrom has some hard constraints which guide its implementation choices, most notably: the bootrom must boot.

It cannot afford to poll the TRNG for an indeterminate amount of time to wait for a random number to appear. Complex

error handling is also undesirable.

A link to the bootrom source can be found in Chapter 5. Consult the source code for the exact implementation of the

per-boot random number generation, in varm_boot_path.c.

The A2 bootrom TRNG code is written in assembly due to various implementation constraints, and may not be that

illuminating. The following is excerpted from the A1 bootrom source, lightly edited for readability:

// Boot RNG is derived by streaming a large number of TRNG ROSC samples

// into the SHA-256. BOOT_TRNG_SAMPLE_BLOCKS is the number of SHA-256

// blocks to hash, each containing 384 samples from the TRNG ROSC:

const int BOOT_TRNG_SAMPLE_BLOCKS = 25;

// Fixed delay is required after TRNG soft reset

trng_hw->trng_sw_reset = -1u;

(void)trng_hw->trng_sw_reset;

(void)trng_hw->trng_sw_reset;

// Initialise SHA internal state by writing START bit

sha256_hw->csr = SHA256_CSR_RESET | SHA256_CSR_START_BITS;

// Sample one ROSC bit into EHR every cycle, subject to CPU keeping up. More

// temporal resolution to measure ROSC phase noise is better, if we use a

// high quality hash function instead of naive VN decorrelation. (Also more

// metastability events, which are a secondary noise source)

trng_hw->sample_cnt1 = 0;

// Disable checks and bypass decorrelators, to stream raw TRNG ROSC samples:

trng_hw->trng_debug_control = -1u;

// Start ROSC if it is not already started

trng_hw->rnd_source_enable = -1u;

// Clear all interrupts (including EHR_VLD) -- we will check this

// later, after seeding RCP.

trng_hw->rng_icr = -1u;

// Each half-block (192 samples) takes approx 235 cycles, so 470 cycles/block:

for (int half_blocks = 0; half_blocks < 2 * BOOT_TRNG_SAMPLE_BLOCKS; ++half_blocks) {

    // Wait for 192 ROSC samples to fill EHR, this should take constant time:

    while (trng_hw->trng_busy)

12.12. TRNG
1214
