---
source_pdf: rp2350-datasheet-4.pdf
repository: llm_database
chapter: Chapter 11. PIO
section: 11.6.4. UART RX
pages: 924-926
type: technical_spec
generated_at: 2026-03-01T03:27:49.792955+00:00
---

# 11.6.4. UART RX

![Page 924 figure](images/fig_p0924.png)

Recalling Figure 58 showing the format of an 8n1 UART:

1
0
2
3
4
5
6
7

Start
Stop
Data (LSB first)
Idle

We can recover the data by waiting for the start bit, sampling 8 times with the correct timing, and pushing the result to

the RX FIFO. Below is possibly the shortest program which can do this:

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_rx/uart_rx.pio Lines 8 - 19

10 ; Minimum viable 8n1 UART receiver. Wait for the start bit, then sample 8 bits

12 ; IN pin 0 is mapped to the GPIO used as UART RX.

13 ; Autopush must be enabled, with a threshold of 8.

15     wait 0 pin 0        ; Wait for start bit

16     set x, 7 [10]       ; Preload bit counter, delay until eye of first data bit

17 bitloop:                ; Loop 8 times

18     in pins, 1          ; Sample data

19     jmp x-- bitloop [6] ; Each iteration is 8 cycles

This works, but it has some annoying characteristics, like repeatedly outputting NUL characters if the line is stuck low.

11.6. Examples
923

RP2350 Datasheet

Ideally, we would want to drop data that is not correctly framed by a start and stop bit (and set some sticky flag to

indicate this has happened), and pause receiving when the line is stuck low for long periods. We can add these to our

program, at the cost of a few more instructions.

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_rx/uart_rx.pio Lines 44 - 63

44 .program uart_rx

45 

46 ; Slightly more fleshed-out 8n1 UART receiver which handles framing errors and

47 ; break conditions more gracefully.

48 ; IN pin 0 and JMP pin are both mapped to the GPIO used as UART RX.

49 

50 start:

51     wait 0 pin 0        ; Stall until start bit is asserted

52     set x, 7    [10]    ; Preload bit counter, then delay until halfway through

53 bitloop:                ; the first data bit (12 cycles incl wait, set).

54     in pins, 1          ; Shift data bit into ISR

55     jmp x-- bitloop [6] ; Loop 8 times, each loop iteration is 8 cycles

56     jmp pin good_stop   ; Check stop bit (should be high)

57 

58     irq 4 rel           ; Either a framing error or a break. Set a sticky flag,

59     wait 1 pin 0        ; and wait for line to return to idle state.

60     jmp start           ; Don't push data if we didn't see good framing.

61 

62 good_stop:              ; No delay before returning to start; a little slack is

63     push                ; important in case the TX clock is slightly too fast.

The second example does not use autopush (Section 11.5.4), preferring instead to use an explicit push instruction, so

that it can condition the push on whether a correct stop bit is seen. The .pio file includes a helper function which

configures the state machine and connects it to a GPIO with the pull-up enabled:

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_rx/uart_rx.pio Lines 67 - 85

67 static inline void uart_rx_program_init(PIO pio, uint sm, uint offset, uint pin, uint baud) {

68     pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, false);

69     pio_gpio_init(pio, pin);

70     gpio_pull_up(pin);

71 

72     pio_sm_config c = uart_rx_program_get_default_config(offset);

73     sm_config_set_in_pins(&c, pin); // for WAIT, IN

74     sm_config_set_jmp_pin(&c, pin); // for JMP

75     // Shift to right, autopush disabled

76     sm_config_set_in_shift(&c, true, false, 32);

77     // Deeper FIFO as we're not doing any TX

78     sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX);

79     // SM transmits 1 bit per 8 execution cycles.

80     float div = (float)clock_get_hz(clk_sys) / (8 * baud);

81     sm_config_set_clkdiv(&c, div);

82 

83     pio_sm_init(pio, sm, offset, &c);

84     pio_sm_set_enabled(pio, sm, true);

85 }

To correctly receive data which is sent LSB-first, the ISR is configured to shift to the right. After shifting in 8 bits, this

unfortunately leaves our 8 data bits in bits 31:24 of the ISR, with 24 zeroes in the LSBs. One option here is an in null, 24

instruction to shuffle the ISR contents down to 7:0. Another is to read from the FIFO at an offset of 3 bytes, with an 8-bit

read, so that the processor’s bus hardware (or the DMA’s) picks out the relevant byte for free:

11.6. Examples
924

RP2350 Datasheet

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_rx/uart_rx.pio Lines 87 - 93

87 static inline char uart_rx_program_getc(PIO pio, uint sm) {

88     // 8-bit read from the uppermost byte of the FIFO, as data is left-justified

89     io_rw_8 *rxfifo_shift = (io_rw_8*)&pio->rxf[sm] + 3;

90     while (pio_sm_is_rx_fifo_empty(pio, sm))

91         tight_loop_contents();

92     return (char)*rxfifo_shift;

93 }

An example program shows how this UART RX program can be used to receive characters sent by one of the hardware

UARTs on RP2350. A wire must be connected from GPIO4 to GPIO3 for this program to function. To make the wrangling

of 3 different serial ports a little easier, this program uses core 1 to print out a string on the test UART (UART 1), and the

code running on core 0 will pull out characters from the PIO state machine, and pass them along to the UART used for

the debug console (UART 0). Another approach here would be interrupt-based IO, using PIO’s FIFO IRQs. If the

SM0_RXNEMPTY bit is set in the IRQ0_INTE register, then PIO will raise its first interrupt request line whenever there is a

character in state machine 0’s RX FIFO.

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_rx/uart_rx.c

 1 /**

 2  * Copyright (c) 2020 Raspberry Pi (Trading) Ltd.

 3  *

 4  * SPDX-License-Identifier: BSD-3-Clause

 5  */

 6 

 7 #include <stdio.h>

 8 

 9 #include "pico/stdlib.h"

10 #include "pico/multicore.h"

11 #include "hardware/pio.h"

12 #include "hardware/uart.h"

13 #include "uart_rx.pio.h"

14 

15 // This program

16 // - Uses UART1 (the spare UART, by default) to transmit some text

17 // - Uses a PIO state machine to receive that text

18 // - Prints out the received text to the default console (UART0)

19 // This might require some reconfiguration on boards where UART1 is the

20 // default UART.

21 

22 #define SERIAL_BAUD PICO_DEFAULT_UART_BAUD_RATE

23 #define HARD_UART_INST uart1

24 

25 // You'll need a wire from GPIO4 -> GPIO3

26 #define HARD_UART_TX_PIN 4

27 #define PIO_RX_PIN 3

28 

29 // Check the pin is compatible with the platform

30 #error Attempting to use a pin>=32 on a platform that does not support it

31 

32 // Ask core 1 to print a string, to make things easier on core 0

33 void core1_main() {

34     const char *s = (const char *) multicore_fifo_pop_blocking();

35     uart_puts(HARD_UART_INST, s);

36 }

37 

38 int main() {

39     // Console output (also a UART, yes it's confusing)

40     setup_default_uart();

41     printf("Starting PIO UART RX example\n");

11.6. Examples
925
