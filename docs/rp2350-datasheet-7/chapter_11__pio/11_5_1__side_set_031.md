---
source_pdf: rp2350-datasheet-7.pdf
repository: llm_database
chapter: Chapter 11. PIO
section: 11.5.1. Side-set
pages: 903-904
type: technical_spec
generated_at: 2026-03-01T06:07:53.318745+00:00
---

# 11.5.1. Side-set

11.5.1. Side-set

Side-set is a feature that allows state machines to change the level or direction of up to 5 pins, concurrently with the

main execution of the instruction.

One example where this is necessary is a fast SPI interface: here a clock transition (toggling 1→0 or 0→1) must be

simultaneous with a data transition, where a new data bit is shifted from the OSR to a GPIO. In this case an OUT with a

side-set would achieve both of these at once.

This makes the timing of the interface more precise, reduces the overall program size (as a separate SET instruction is

not needed to toggle the clock pin), and also increases the maximum frequency the SPI can run at.

Side-set also makes GPIO mapping much more flexible, as its mapping is independent from SET. The example I2C code

allows SDA and SCL to be mapped to any two arbitrary pins, if clock stretching is disabled. Normally, SCL toggles to

synchronise data transfer, and SDA contains the data bits being shifted out. However, some particular I2C sequences

such as Start and Stop line conditions, need a fixed pattern to be driven on SDA as well as SCL. The mapping I2C uses to

achieve this is:

• Side-set → SCL

11.5. Functional details
902

RP2350 Datasheet

• OUT → SDA
• SET → SDA

This lets the state machine serve the two use cases of data on SDA and clock on SCL, or fixed transitions on both SDA

and SCL, while still allowing SDA and SCL to be mapped to any two GPIOs of choice.

The side-set data is encoded in the Delay/side-set field of each instruction. Any instruction can be combined with side-

set, including instructions which write to the pins, such as OUT PINS or SET PINS. Side-set’s pin mapping is independent

from OUT and SET mappings, though it may overlap. If side-set and an OUT or SET write to the same pin simultaneously, the

side-set data is used.

NOTE

If an instruction stalls, the side-set still takes effect immediately.

1 .program spi_tx_fast

2 .side_set 1

3 

4 loop:

5     out pins, 1  side 0

6     jmp loop     side 1

The spi_tx_fast example shows two benefits of this: data and clock transitions can be more precisely co-aligned, and

programs can be made faster overall, with an output of one bit per two system clock cycles in this case. Programs can

also be made smaller.

There are four things to configure when using side-set:

• The number of MSBs of the Delay/side-set field to use for side-set rather than delay. This is configured by

PINCTRL_SIDESET_COUNT. If this is set to 5, delay cycles are not available. If set to 0, no side-set will take place.
• Whether to use the most significant of these bits as an enable. Side-set takes place on instructions where the

enable is high. If there is no enable bit, every instruction on that state machine will perform a side-set, if

SIDESET_COUNT is nonzero. This is configured by EXECCTRL_SIDE_EN.
• The GPIO number to map the least-significant side-set bit to. Configured by PINCTRL_SIDESET_BASE.
• Whether side-set writes to GPIO levels or GPIO directions. Configured by EXECCTRL_SIDE_PINDIR

In the above example, we have only one side-set data bit, and every instruction performs a side-set, so no enable bit is

required. SIDESET_COUNT would be 1, SIDE_EN would be false. SIDE_PINDIR would also be false, as we want to drive the clock

high and low, not high- and low-impedance. SIDESET_BASE would select the GPIO the clock is driven from.
