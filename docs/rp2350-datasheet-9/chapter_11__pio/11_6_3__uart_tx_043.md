---
source_pdf: rp2350-datasheet-9.pdf
repository: llm_database
chapter: Chapter 11. PIO
section: 11.6.3. UART TX
pages: 922-924
type: technical_spec
generated_at: 2026-03-01T11:44:31.548839+00:00
---

# 11.6.3. UART TX

11.6.3. UART TX

![Page 922 figure](images/fig_p0922.png)

*Figure 58. UART serial format. The line is high when idle. The transmitter pulls the line down for one bit period to signify the*

This program implements the transmit component of a universal asynchronous receive/transmit (UART) serial

start of a serial frame

peripheral. Perhaps it would be more correct to refer to this as a UAT.

(the "start bit"), and a

small, fixed number of

data bits follows. The

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_tx/uart_tx.pio Lines 8 - 18

line returns to the idle

state for at least one

```c
 8 .program uart_tx
```

bit period (the "stop

```c
 9 .side_set 1 opt
```

bit") before the next

```c
10 
```

serial frame can

begin.

```c
11 ; An 8n1 UART transmit program.
12 ; OUT pin 0 and side-set pin 0 are both mapped to UART TX pin.
13 
14     pull       side 1 [7]  ; Assert stop bit, or stall with line in idle state
15     set x, 7   side 0 [7]  ; Preload bit counter, assert start bit for 8 clocks
16 bitloop:                   ; This loop will run 8 times (8n1 UART)
17     out pins, 1            ; Shift 1 bit from OSR to the first OUT pin
18     jmp x-- bitloop   [6]  ; Each loop iteration is 8 cycles.
```

As written, it will:

1. Stall with the pin driven high until data appears (noting that side-set takes effect even when the state machine is

stalled)

2. Assert a start bit, for 8 SM execution cycles

3. Shift out 8 data bits, each lasting for 8 cycles

4. Return to the idle line state for at least 8 cycles before asserting the next start bit

If the state machine’s clock divider is configured to run at 8 times the desired baud rate, this program will transmit well-

formed UART serial frames, whenever data is pushed to the TX FIFO either by software or the system DMA. To extend

the program to cover different frame sizes (different numbers of data bits), the set x, 7 could be replaced with mov x, y,

so that the y scratch register becomes a per-SM configuration register for UART frame size.

The .pio file in the SDK also contains this function, for configuring the pins and the state machine, once the program

has been loaded into the PIO instruction memory:

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_tx/uart_tx.pio Lines 24 - 51

```c
24 static inline void uart_tx_program_init(PIO pio, uint sm, uint offset, uint pin_tx, uint
   baud) {
25     // Tell PIO to initially drive output-high on the selected pin, then map PIO
26     // onto that pin with the IO muxes.
27     pio_sm_set_pins_with_mask64(pio, sm, 1ull << pin_tx, 1ull << pin_tx);
28     pio_sm_set_pindirs_with_mask64(pio, sm, 1ull << pin_tx, 1ull << pin_tx);
29     pio_gpio_init(pio, pin_tx);
30 
31     pio_sm_config c = uart_tx_program_get_default_config(offset);
```

11.6. Examples
921

RP2350 Datasheet

```c
32 
33     // OUT shifts to right, no autopull
34     sm_config_set_out_shift(&c, true, false, 32);
35 
36     // We are mapping both OUT and side-set to the same pin, because sometimes
37     // we need to assert user data onto the pin (with OUT) and sometimes
38     // assert constant values (start/stop bit)
39     sm_config_set_out_pins(&c, pin_tx, 1);
40     sm_config_set_sideset_pins(&c, pin_tx);
41 
42     // We only need TX, so get an 8-deep FIFO!
43     sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX);
44 
45     // SM transmits 1 bit per 8 execution cycles.
46     float div = (float)clock_get_hz(clk_sys) / (8 * baud);
47     sm_config_set_clkdiv(&c, div);
48 
49     pio_sm_init(pio, sm, offset, &c);
50     pio_sm_set_enabled(pio, sm, true);
51 }
```

The state machine is configured to shift right in out instructions, because UARTs typically send data LSB-first. Once

configured, the state machine will print any characters pushed to the TX FIFO.

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_tx/uart_tx.pio Lines 53 - 55

```c
53 static inline void uart_tx_program_putc(PIO pio, uint sm, char c) {
54     pio_sm_put_blocking(pio, sm, (uint32_t)c);
55 }
```

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_tx/uart_tx.pio Lines 57 - 60

```c
57 static inline void uart_tx_program_puts(PIO pio, uint sm, const char *s) {
58     while (*s)
59         uart_tx_program_putc(pio, sm, *s++);
60 }
```

The example program in the SDK will configure one PIO state machine as a UART TX peripheral, and use it to print a

message on GPIO 0 at 115200 baud once per second.

Pico Examples: https://github.com/raspberrypi/pico-examples/blob/master/pio/uart_tx/uart_tx.c

```c
 1 /**
 2  * Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
 3  *
 4  * SPDX-License-Identifier: BSD-3-Clause
 5  */
 6 
 7 #include "pico/stdlib.h"
 8 #include "hardware/pio.h"
 9 #include "uart_tx.pio.h"
10 
11 // We're going to use PIO to print "Hello, world!" on the same GPIO which we
12 // normally attach UART0 to.
13 #define PIO_TX_PIN 0
14 
15 // Check the pin is compatible with the platform
16 #error Attempting to use a pin>=32 on a platform that does not support it
```

11.6. Examples
922

RP2350 Datasheet

```c
17 
18 int main() {
19     // This is the same as the default UART baud rate on Pico
20     const uint SERIAL_BAUD = 115200;
21 
22     PIO pio;
23     uint sm;
24     uint offset;
25 
26     // This will find a free pio and state machine for our program and load it for us
27     // We use pio_claim_free_sm_and_add_program_for_gpio_range (for_gpio_range variant)
28     // so we will get a PIO instance suitable for addressing gpios >= 32 if needed and
   supported by the hardware
29     bool success = pio_claim_free_sm_and_add_program_for_gpio_range(&uart_tx_program, &pio,
   &sm, &offset, PIO_TX_PIN, 1, true);
30     hard_assert(success);
31 
32     uart_tx_program_init(pio, sm, offset, PIO_TX_PIN, SERIAL_BAUD);
33 
34     while (true) {
35         uart_tx_program_puts(pio, sm, "Hello, world! (from PIO!)\r\n");
36         sleep_ms(1000);
37     }
38 
39     // This will free resources and unload our program
40     pio_remove_program_and_unclaim_sm(&uart_tx_program, pio, sm, offset);
41 }
```

With the two PIO instances on RP2350, this could be extended to 8 additional UART TX interfaces, on 8 different pins,

with 8 different baud rates.
